Jarvis 逆向 DD-android normal
=============================

一个apk程序,先用手机装上看了一下,随意输入,出现**Wrong**字段
用APK 改之理 打开,搜索**Wrong**字段,然后定位到
**com/didictf/hellolibs/MainActivity**找到主要程序
APK改之理反编译的代码会保存在相应的WorkSrc目录下
定位到具体文件处.再结合jd-gui打开**MainActivity.class**文件
```java
package com.didictf.hellolibs;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.view.View;
import android.widget.TextView;

public class MainActivity
  extends AppCompatActivity
{
  private TextView mFlagEntryView;
  private TextView mFlagResultView;
  
  static
  {
    System.loadLibrary("hello-libs");
  }
  
  public void onClickTest(View paramView)
  {
    if (this.mFlagEntryView.getText().toString().equals(stringFromJNI()))
    {
      this.mFlagResultView.setText("Correct");
      return;
    }
    this.mFlagResultView.setText("Wrong");
  }
  
  protected void onCreate(Bundle paramBundle)
  {
    super.onCreate(paramBundle);
    setContentView(2130968602);
    this.mFlagEntryView = ((TextView)findViewById(2131427413));
    this.mFlagResultView = ((TextView)findViewById(2131427415));
  }
  
  public native String stringFromJNI();
}
```
>主要代码有三处
>>`System.loadLibrary("hello-libs");`
>>表示加载第三方库hello-libs
>>`this.mFlagEntryView.getText().toString().equals(stringFromJNI())`
>>将输入字符串与stringFromJNI函数返回字符串对比
>>`public native String stringFromJNI();`
>>stringFromJNI函数是native函数,从hello-libs中加载的

解压APK找到其中的库文件,lib文件夹下面有七个文件夹.他们分别是不同的cpu架构
上面这些文件夹里都存放着程序引入的第三方库，也就是 .so 文件。
mips、armeabi、armeabi-v7a和x86都表示CPU的类型。一般的手机或平板都是用arm的cpu。不同的cpu的特性不一样。
*armeabi  是针对普通的或旧的arm v5 cpu，32位
*armeabi-v7a 是针对有浮点运算或高级扩展功能的arm v7 cpu，32位
*arm64-v8a 针对64位的
*mips  是一种采取精简指令集（RISC）的处理器架构，32位
*mips64  64位
*x86   IA-32位指令集
*x86_64  64位
用IDA打开armeabi-v7a目录下的libhello-libs.so文件
 
主要是红框中的内容,点击函数,找到真实的加密的地方.
```C
int __fastcall __aeabi_wind_cpp_pr45(char *a1)
{
  char *v1; // r4
  int v2; // r1
  int v3; // r3
  int v4; // r6
  int v5; // r5
  int v6; // r2
  char v8[182]; // [sp+6h] [bp-CAh]
  int v9; // [sp+BCh] [bp-14h]

  v1 = a1;
  v2 = 0;
  do
  {
    v8[v2] = byte_66C[v2] ^ byte_722[v2];	//将两个数组按位异或运算
    ++v2;
  }
  while ( v2 != 182 );	//v8的数组的长度为182,就是将两个数组的异或运算存储在v8中
  v3 = 0;
  do		// 找到v8数组中值为0的地方,把下标赋值给v3.v8[0]的值是57,
	//所以寻找的范围是v8数组下标的28~182
    v4 = (unsigned __int8)v8[((unsigned int)(unsigned __int8)v8[0] >> 1) + v3++];
  while ( v4 );
  v5 = v3 - 1;
  v6 = 0;	
  if ( v3 - 1 >= 1 )
  {		//截取v8字符串从28~v3;
    _aeabi_memcpy(a1, &v8[(unsigned int)(unsigned __int8)v8[0] >> 1], v3 - 1);
    v6 = v5;
  }
  v1[v6] = 0;
  return _stack_chk_guard - v9;
}
```

最后的python脚本
```python
key1 =[0xD8,0xC2,0x6B,0x42,0x82,0x67,0xC8,0x4D,0x7A,0x95,0xE8,0x81,0x48,0xC1,0x9E,0x40,0xE8,0xFB,0xCF,0xE6,0x4F,0xBA,0xE6,0xAF,0x78,0x19,0x6F,0x9C,0xE9,0xF7,0x7A,0xDD,0x42,0xCE,0x8C,3,0xB8,0x66,0xD3,0xAB,0,0x7E,0xDE,0x3E,0x53,0xDE,0x30,0x91,0x3D,0xF7,0xCD,0x72,0x14,0x51,0x82,0xEE,0x1B,0x8D,0xB4,0x8C,0xD0,0x8A,0xF6,0x9A,0x96,0x71,0x98,0x62,0x93,0x4A,0x30,0x2F,0x9C,0xA8,0x79,0x16,0xC1,0xE0,0xEC,0xD7,0xE5,0xEC,0x8A,0x64,0xB4,0x46,0xCF,0xD9,0xE5,0x96,0xF3,0x94,0x73,0xA9,0xFF,0xEA,0xCB,0x15,0x9C,0x7C,0xA1,0xD8,0x3E,0xBB,0x1D,0x38,0xCB,0x55,0xD0,0x19,0x25,0xB2,0xB,0x92,0xE8,0x88,0xAE,6,0xA2,0x9B,0x93,0x64,0x5E,0xFB,9,5,0xF6,0x2F,0x1F,0x35,0xCC,0xEF,5,0x6C,0x19,0x42,0x38,0xA5,0x59,0x2E,0x80,0xA,0x19,0xFC,0x33,0x5B,0xBB,0xD6,0xEB,0x2B,0xAC,0xF7,0xE,0xAD,0xD8,0x57,0x40,0x98,0x71,0x2C,0x78,0x68,0x91,0x82,0x4F,0x5B,0xD6,0x40,0x8F,3,0xBD,0x55,0xB,0x47,0x3D,0xF4,0x5A,0x49,0x5B,0xF2,0xA2,0x9E]
key2 =[0xE1,0xA1,1,0xE4,0x82,0x56,0x9D,0x70,0xD9,0xF5,8,0x10,0x22,0xA7,0x2D,0x2B,0x41,0xF0,0xBD,0xA4,0x67,0x3D,0x9A,0x20,0xB9,0xFB,0x11,0xD3,0xAD,0xB3,0x39,0x89,4,0xE3,0xBF,0x3A,0x8F,7,0xEA,0x9B,0x61,0x4D,0xEC,8,0x64,0xE8,4,0xA0,0xB,0xC2,0xF5,0x10,0x76,0x32,0xBB,0xD9,0x2E,0xBE,0x86,0xBA,0xE7,0xBA,0xC6,0xFC,0xA2,0x13,0xD8,6,0xFA,0x2E,0x59,0x4C,0xF4,0xDD,1,0x7F,0xAF,0x87,0xC2,0xB4,0x8A,0x81,0x8A,0xF2,0xB6,0x60,0x9A,0x13,0x52,0xC0,0x6D,0x9E,0x5A,0x52,0xB5,0x8F,0x47,0x5E,0xE6,0x41,0xAD,0xF5,0xBB,0xA9,0x7A,0x6C,0xA1,0x4C,0x38,0x60,0xF2,0x4B,0x5C,0xE8,0x5B,0xE5,0xE3,0xBA,0x46,0x70,0x33,4,0xA7,0x58,0x19,0x10,0x49,0x20,0x1D,0x51,0x48,0x9D,0x78,0xF9,0xB4,0x2E,0x66,0x58,0x1B,0xE8,0xEE,0x51,9,0x21,0x80,0xBC,0xC8,0x7B,0xF5,0x4E,0x99,0xFD,0xFC,0x9A,0xFD,0x65,0x20,0x13,0x57,0xD1,0x83,0x4D,0xF6,0x2C,0xAF,0x25,0x3C,0x12,0xF0,0x7C,0x16,0x66,0x97,0x7F,0x6A,2,0xBC,0x98,0x52,0xD7,0xE3,0x56]
key3  =[]

ans =''
for i in range(182):
    key3.append(key1[i] ^ key2[i])

for c in key3:
    ans += chr(c)

for i in range(28,182):
    if key3[i] == 0:
        print(key3[i])
        print(i)

print(ans[28:82])
#print(ans) 可以不用理解,直接爆破从中找到答案
```

得到flag
>DDCTF-397a90a3267641658bbc975326700f4b@didichuxing.com
